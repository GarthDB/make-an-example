/**
 * Public: parses the `toString` result of a function to get argument names.
 *
 * * `func` {Function} that will be parsed for argument names or function {String}
 *
 * ## Example
 *
 *    function aFunc(arg1, arg2) {
 *      return [arg1, arg2];
 *    }
 *    getArgsNames(aFunc);
 *    //returns ['arg1', 'arg2'];
 *
 * Returns {Array} of argument name {Strings}
 */
export function getArgsNames(func) {
  const funcString = (typeof func === 'function') ? func.toString() : func;
  // First match everything inside the function argument parens.
  const args = funcString.match(/function\s.*?\(([^)]*)\)/)[1];
  // Split the arguments string into an array comma delimited.
  return args.split(',').map(arg => arg.replace(/\/\*.*\*\//, '').trim()).filter(arg => arg);
}
/**
 * Public: parses `toString` result of a function to get function name.
 *
 * * `func` {Function} that will be parsed for argument names or function {String}
 *
 * ## Example
 *
 *    function aFunc(arg1, arg2) {
 *      return [arg1, arg2];
 *    }
 *    getFuncName(aFunc);
 *    //returns 'aFunc';
 *
 * Returns {String} of function name
 */
export function getFuncName(func) {
  const funcString = (typeof func === 'function') ? func.toString() : func;
  // First match everything inside the function argument parens.
  const name = funcString.toString().match(/function(\s.*)?\((?:[^)]*)\)/)[1];
  return name.trim();
}
/**
 * Public: matches argument names and argument values into an {Object}.
 *
 * * `names` {Array} of argument name {Strings} or arguments {Object} from a function.
 * * `values` {Array} of arguement values (can be anything)
 *
 * ## Example
 *
 *    function aFunc(arg1, arg2) {
 *      return arguments;
 *    }
 *    const args = aFunc('value 1', 'value 2');
 *    const argNames = getArgsNames(aFunc);
 *    const argsObj = generateArgsObj(argNames, args);
 *    // returns { arg1: 'value 1', arg2: 'value 2' }
 *
 * Returns {Object} with argument names as keys and argument values as values.
 * Extra arguments are returned as an array on the `extraArgs` property.
 */
export function generateArgsObj(names, values) {
  const result = { args: {} };
  const extraArgs = [];
  const valuesArray = (!Array.isArray(values)) ? Array.prototype.slice.call(values) : values;
  valuesArray.forEach((value, index) => {
    if (names[index]) {
      result.args[names[index]] = values[index];
    } else {
      extraArgs.push(value);
    }
  });
  if (extraArgs.length) {
    result.extraArgs = extraArgs;
  }
  return result;
}
/**
 * Public: generates function object by adding the function name to an `argsObj`.
 *
 * * `functionName` {String} name of the function
 * * `argsObj` Arguments {Object} generated by `generateArgsObj()`
 *
 * ## Example
 *
 *    function aFunc(arg1, arg2) {
 *      return arguments;
 *    }
 *    const args = aFunc('value 1', 'value 2');
 *    const funcName = getFuncName(aFunc);
 *    const argNames = getArgsNames(aFunc);
 *    const argValues = Array.prototype.slice.call(args);
 *    const argsObj = generateArgsObj(argNames, argValues);
 *    generateFunctionObj(funcName, argsObj);
 *
 * would return:
 *
 *    const expected = {
 *      name: 'aFunc',
 *      args: { arg1: 'value 1', arg2: 'value 2' },
 *    };
 *
 * Returns Function {Object}
 */
export function generateFunctionObj(functionName, argsObj) {
  return Object.assign({ name: functionName }, argsObj);
}
/**
 * Public: passes function name, argument names and values (including extra arguemnts)
 * to logFunction (defaults to console.log).
 *
 * * `funcObject` Function {Object} returned by `generateFunctionObj()`.
 * * `logFunction` {Function} to pass log messages to. Defaults to `console.log`.
 *   * `message` {String} `logFunction` should expect a message argument.
 *
 * ## Example
 *
 *    function aFunc(arg1, arg2) {
 *      return arguments;
 *    }
 *    const args = aFunc('value 1', 'value 2', 'extra 1', 'extra 2');
 *    const funcName = getFuncName(aFunc);
 *    const argNames = getArgsNames(aFunc);
 *    const argValues = Array.prototype.slice.call(args);
 *    const argsObj = generateArgsObj(argNames, argValues);
 *    const funcObj = generateFunctionObj(funcName, argsObj);
 *    formatExample(funcObj);
 *
 * Would log the following to the console:
 *
 *    ---
 *    aFunc
 *    arg1 argument:
 *    value 1
 *    arg2 argument:
 *    value 2
 *    Extra Argument [0]:
 *    extra 1
 *    Extra Argument [1]:
 *    extra 2
 *
 * Does not return a value, but passes messages to `logFunction`.
 */
// eslint-disable-next-line no-console
export function formatExample(funcObject, logFunction = console.log) {
  logFunction('---');
  logFunction(funcObject.name);
  Object.keys(funcObject.args).forEach(name => {
    logFunction(`${name} argument:`);
    logFunction(funcObject.args[name]);
  });
  if ({}.hasOwnProperty.call(funcObject, 'extraArgs')) {
    funcObject.extraArgs.forEach((extraArg, index) => {
      logFunction(`Extra Argument [${index}]:`);
      logFunction(extraArg);
    });
  }
}
/**
 * Public: MakeAnExample class constructor that logs function data
 *
 * * `func` {Function} to be introspected.
 * * `args` arguments {Object} of a function.
 * * `formatFunction` {Function} formats messages to `logFunction`.
 * * `logFunction` log messages with be passed to this {Function}.
 *
 * ## Example
 *
 *    function aFunc(arg1, arg2) {
 *      return arguments;
 *    }
 *    const args = aFunc('value 1', 'value 2', 'extra 1', 'extra 2');
 *    makeAnExample(aFunc, args, formatExample, format);
 *
 * Would log the following to the console:
 *
 *    ---
 *    aFunc
 *    arg1 argument:
 *    value 1
 *    arg2 argument:
 *    value 2
 *    Extra Argument [0]:
 *    extra 1
 *    Extra Argument [1]:
 *    extra 2
 *
 * Does not return a value, but passes messages to `logFunction`.
 */
export default function makeAnExample(
  func, args, formatFunction = formatExample, logFunction = undefined
) {
  const argNames = getArgsNames(func);
  const functionName = getFuncName(func);
  const argsObj = generateArgsObj(argNames, args);
  const funcObject = generateFunctionObj(functionName, argsObj);
  formatFunction(funcObject, logFunction);
}
